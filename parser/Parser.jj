options {
	STATIC = false;
	DEBUG_PARSER = true;
	UNICODE_INPUT = true;
	JDK_VERSION = "1.6";
}

PARSER_BEGIN(Parser)
import java.io.*;

class Parser {
	static public void main(String[] args) {
		for (String arg : args) {
			try {
				System.out.println(evaluate(arg));
			}
			catch (ParseException ex) {
				System.err.println(ex.getMessage());
			}
		}
	}
	static public long evaluate(String src) throws ParseException {
		Reader reader = new StringReader(src);
		return new Parser(reader).expr();
	}
	private String sourceName;
	private LibraryLoader loader;
	private ErrorHandler errorHandler;
	private Set<String> knownTypedefs;
	public Parser(Reader s, String name, LibraryLoader loader,
	ErrorHandler errorHandler, boolean debug) {
		this(s);
		this.sourceName = name;
		this.loader = loader;
		this.errorHandler = errorHandler;
		this.knownTypedefs = new HashSet<String>();
		if (debug) {
			enable_tracing();
		}
		else {
			disable_tracing();
		}
	}
	static public AST parseFile(File file, LibraryLoader loader,
	ErrorHandler errorHandler, boolean debug)
	throws SyntaxException, FileException {
		return newFileParser(file, loader, errorHandler, debug).parse();
	}
	static final public String SOURCE_ENCODING = "UTF-8";
	static public Parser newFileParser(File file,
	LibraryLoader loader,
	ErrorHandler errorHandler,
	boolean debug)
	throws FileException {
		try {
			BufferedReader r =
			new BufferedReader(
			new InputStreamReader(new FileInputStream(file),
			SOURCE_ENCODING));
			return new Parser(r, file.getPath(), loader, errorHandler, debug);
		}
		catch (FileNotFoundException ex) {
			throw new FileException(ex.getMessage());
		}
		catch (UnsupportedEncodingException ex) {
			throw new Error("UTF-8 is not supported??: " + ex.getMessage());
		}
	}
	public AST parse() throws SyntaxException {
		try {
			return compilation_unit();
		}
		catch (TokenMgrError err) {
			throw new SyntaxException(err.getMessage());
		}
		catch (ParseException ex) {
			throw new SyntaxException(ex.getMessage());
		}
		catch (LookaheadSuccess err) {
			throw new SyntaxException("syntax error");
		}
	}
}

PARSER_END(Parser)

TOKEN: {
	<VOID: "void">
|	<NULL: "null">
|	<BOOL: "bool">
|	<TRUE: "true">
|	<FALSE: "false">
|   <INT: "int">
|   <CLASS: "class">
|   <IF: "if">
|   <ELSE: "else">
|   <WHILE: "while">
|   <FOR: "for">
|   <RETURN: "return">
|   <BREAK: "break">
|   <CONTINUE: "continue">
|   <IDENTIFIER: ["a"-"z", "A"-"Z", "_"] (["a"-"z", "A"-"Z", "_", "0"-"9"])*>
| 	<INTEGER: ["1"-"9"] (["0"-"9"])*>
}

SPECIAL_TOKEN: {
	<SPACES: ([" ", "\t", "\n", "\r", "\f"])+>
|	<LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r\n" | "\r")?> 
}

MORE: {
  	<"\""> : IN_STRING
}
<IN_STRING> MORE: {
	<(~["\"", "\\", "\n", "\r"])+>
|	<"\\" (["0"-"7"]){3}>
|	<"\\" ~[]>
}
<IN_STRING> TOKEN: { <STRING: "\""> : DEFAULT }
String name():
{
    Token t;
}
{
    t=<IDENTIFIER> { return t.image; }
}
Params params():
{
    Token t;
    Params params;
}
{
      LOOKAHEAD(<VOID> ")")
      t=<VOID>
        {
            return new Params(location(t), new ArrayList<Parameter>());
        }
    | params=fixedparams()
            ["," "..." { params.acceptVarargs(); }]
        {
            return params;
        }
}
Params fixedparams():
{
    List<Parameter> params = new ArrayList<Parameter>();
    Parameter param, param1;
}
{
    param1=param() { params.add(param1); }
    ( LOOKAHEAD(2) "," param=param() { params.add(param); } )*
        {
            return new Params(param1.location(), params);
        }
}
Parameter param():
{
    TypeNode t;
    String n;
}
{
    t=type() n=name() { return new Parameter(t, n); }
}
void block(): {}
{
	"{" defvar_list() stmts() "}"
}
void type(): {}
{
	typeref()
}
void typeref(): {}
{
	typeref_base()
	( LOOKAHEAD(2) "[" "]"
|	"[" <INTEGER> "]")*
}
void typeref_base(): {}
{
	<VOID>
|	<INT>
| LOOKAHEAD({isType(getToken(1).image)}) <IDENTIFIER>
}
void stmts(): {}
{
	(stmt())*
}
void stmt(): {}
{
	( ";"
	|	expr() ";"
	|	block()
	|	if_stmt()
	|	while_stmt()
	|	for_stmt()
	|	break_stmt()
	|	continue_stmt()
	|	return_stmt()
	)
}
void if_stmt(): {}
{
	<IF> "(" expr() ")" stmt() [LOOKAHEAD(1) <ELSE> stmt()]
}
void while_stmt(): {}
{
	<WHILE> "(" expr() ")" stmt()
}
void for_stmt(): {}
{
	<FOR> "(" [expr()] ";" [expr()] ";" [expr()] ")" stmt()
}
void break_stmt(): {}
{
	<BREAK> ";"
}
void continue_stmt(): {}
{
	<CONTINUE> ";"
}
void return_stmt(): {}
{
	LOOKAHEAD(2) <RETURN> ";"
|	<RETURN> expr() ";"
}
void expr(): {}
{
	LOOKAHEAD(term() "=")
	term() "=" expr()
|	LOOKAHEAD(term() opassign_op())
	term() opassign_op() expr()
|	expr10()
}
void opassign_op(): {}
{
	( "+="
	| "-="
	| "*="
	| "/="
	| "%="
	| "&="
	| "|="
	| "^="
	| "<<="
	| ">>="
	)
}
void expr10(): {}
{
	expr9() ["?" expr() ":" expr10()]
}
void expr9(): {}
{
	expr8() ("||" expr8())*
}
void expr8(): {}
{
	expr7() ("&&" expr7())*
}
void expr7(): {}
{
	expr6() ( ">" expr6()
|	"<" expr6()
|	">=" expr6()
|	"<=" expr6()
|	"==" expr6()
|	"!=" expr6() )*
}
void expr6(): {}
{
	expr5() ("|" expr5())*
}
void expr5(): {}
{
	expr4() ("^" expr4())*
}
void expr4(): {}
{
	expr3() ("&" expr3())*
}
void expr3(): {}
{
	expr2() ( ">>" expr2()
|	"<<" expr2()
)*
}
void expr2(): {}
{
	expr1() ( "+" expr1()
|	"-" expr1()
)*
}
void expr1(): {}
{
	term() ( "*" term()
|	"/" term()
|	"%" term()
)*
}
void term(): {}
{
	LOOKAHEAD("(" type()) "(" type() ")" term()
|	unary()
}
void unary(): {}
{
	"++" unary() 
|	"--" unary() 
|	"+" term() 
|	"-" term()
|	"!" term() 
|	"~" term() 
|	"*" term()
|	"&" term()
|	postfix()
}
void postfix(): {}
{
	primary()
	( "++" 
	|	"--" 
	|	"[" expr() "]"
	|	"." name() 
	|	"->" name() 
	|	"(" args() ")" 
	)*
}
void args(): {}
{
	[ expr() ("," expr())* ]
}
void primary(): {}
{
	<INTEGER>
|	<STRING>
|	<IDENTIFIER>
|	"(" expr() ")"
}
List<DefinedVariable> defvars():
{
	List<DefinedVariable> defs = new ArrayList<DefinedVariable>();
	TypeNode type;
	String name;
	ExprNode init = null;
}
{
	 type=type() name=name() ["=" init=expr()]
		{
			defs.add(new DefinedVariable(type, name, init));
			init = null;
		}
	( "," name=name() ["=" init=expr()]
		{
			defs.add(new DefinedVariable(type, name, init));
			init = null;
		}
	)* ";"
		{
			return defs;
		}
}
DefinedFunction defun():
{
	TypeRef ret;
	String n;
	Params ps;
	BlockNode body;
}
{
	ret=typeref() n=name() "(" ps=params() ")" body=block()
		{
			TypeRef t = new FunctionTypeRef(ret, ps.parametersTypeRef());
			return new DefinedFunction(new TypeNode(t), n, ps, body);
		}
}
List<DefinedVariable> defvar_list():
{
	List<DefinedVariable> result = new ArrayList<DefinedVariable>();
	List<DefinedVariable> vars;
}
{
	( vars=defvars() { result.addAll(vars); } )*
		{
			return result;
		}
}
Declarations top_defs():
{
	Declarations decls = new Declarations();
	DefinedFunction defun;
	List<DefinedVariable> defvars;
	Constant defconst;
	StructNode defstruct;
	UnionNode defunion;
	TypedefNode typedef;
}
{
	( LOOKAHEAD(typeref() <IDENTIFIER> "(")
		defun=defun() { decls.addDefun(defun); }
	|	LOOKAHEAD(3)
		defvars=defvars() { decls.addDefvars(defvars); }
	)*
		{
			return decls;
		}
}
AST compilation_unit():
{
	Token t;
	Declarations decls;
}
{
	{
		t = getToken(1);
	}
	decls=top_defs() <EOF>
		{
			return new AST(location(t), decls);
		}
}
